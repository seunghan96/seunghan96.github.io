---
title: (Chapter 14) Recovery
categories: [SQL,CS]
tags: [SQL]
excerpt: 연세대학교 데이터베이스 시스템 수업 (CSI6541)
---

<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
( 출처 : 연세대학교 데이터베이스 시스템 수업 (CSI6541) 강의자료 )

# Chapter 14. Recovery

<br>



Contents

- Failure Classification
- Recovery and Atomicity 
- Log-Based Recovery 
- Shadow Paging
- Recovery with Concurrent Transactions
- Buffer Management

<br>

# (1) Failure Classification

## a) Transaction failure

(1) Logical errors : 

- **transaction cannot complete**, due to some **logical error condition**

<br>

(2) System errors: 

- the **DB system must terminate an active transaction** due to an **error condition (e.g., deadlock)**

<br>

(3) System crash: 

- a **power failure** or other **hardware or software failure** causes the system to crash

<br>

(4) Disk failure: 

- a head crash or similar disk failure destroys **all or part of disk storage**

<br>

## b) Recovery Algorithms

Definition )

- techniques to ensure **(1) DB consistency**, **(2) transaction atomicity**, and **(3) durability** despite failures

<br>

Consists of 2 parts :

- (1)  Actions taken ***DURING*** normal transaction processing
  - to **ensure enough information exists** to recover from failures 

- (2) Actions taken ***AFTER*** a failure 
  - to **recover** the DB contents to a state that ensures atomicity, consistency, and durability 

<br>

## c) Data Access

Definitions )

- **Physical blocks** : blocks residing on the disk

- **Buffer blocks** : blocks residing temporarily in main memory

<br>

**Block movements** between disk & main memory :

- are initiated through **input**(B) and **output**(B) operations

<br>

Each transaction $T_i$ has its **"private work-area"**,

where **local copies of all data items** accessed and updated by $T_i$ are kept

<br>

( for simplicity, assume that **each data item fits in a single block** )

<br>

Transaction transfers data items between **(1) buffer blocks** & **(2) its private work-area** using **read**(X) and **write**(X) operations

<br>

Transactions

- Perform **read**(X) when accessing X for the first time

- All subsequent accesses are to the local copy

- After last access, transaction executes **write**(X)

<br>

**Output**(BX) does not need to follow **write**(X) immediately

![figure2](/assets/img/sql/img115.png)

# (2) Recovery and Atomicity 

**Inconsistent state**

- Modifying the DB, ***without ensuring that the transaction will commit*** may leave the database in an inconsistent state

<br>

Example )

- Transaction $T_i$ : transfers $50 from account A to account B
- Goal : either to perform **"all"** DB modifications made by $T_i$ or **"none at all"**
- Several output operations may be required for $T_i$

$\rightarrow$ A failure may occur after **one of these modifications have been made** but **before all of them are made**

<br>

To ensure atomicity despite failures ...

$\rightarrow$ we first output information describing the modifications to **stable storage ** without modifying the DB itself

<br>

2 approaches

- (1) Log-based recovery
- (2) Shadow-paging

<br>

We assume (initially) that **transactions run serially**

<br>

# (3) Log-Based Recovery 

Log = sequence of log records

- records all the update activities in the DB

<br>

When transaction $T_i$  starts....

- (1) Registers itself by writing a <$T_i$ **start**> log record
- (2) Before $T_i$ executes **write**(X), a log record <Ti, X, V1, V2> is written
  - where V1 is an old value and V2 is a new value
- (3) When $T_i$ finishes its last statement, the log record <Ti **commit**> is written

<br>

Assumption

- log records are written directly to **stable storage**

  ( = they are not buffered )

<br>

2 approaches using logs:

- (1) Deferred DB modification
- (2) **Immediate** DB modification

<br>

## a) Deffered DB modification



<br>

## b) Immediate DB modification



<br>

# (4) Shadow Paging

<br>

# (5) Recovery with Concurrent Transactions

<br>

# (6) Buffer Management

