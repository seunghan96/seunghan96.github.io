---
title: 2-2) 운영체제 - 프로세스와 스레드
categories: [CS, OS]
tags: []
excerpt: 
---

<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

(참고: Fastcampus 강의, 강민철의 인공지능 시대 필수 컴퓨터 공학 지식)

# 2. 프로세스와 스레드

## Contents

1. 커널 영역과 사용자 영역의 프로세스
2. 문맥 교환
3. 사용자 영역
4. 프로세스 생성과 상태
5. 스레드
6. 멀티 프로세스 & 멀티 스레드

<br>

## (1) 커널 영역과 사용자 영역의 프로세스

프로세스 = **"실행 중인"** 프로그램

- 참고) 같은 프로그램도, 별도의 프로세스가 될 수 있다!

<br>

### a) 명령어

```bash
ps -ef
```

ps -ef는 **리눅스/유닉스에서 프로세스 정보를 확인**할 때 자주 사용하는 명령어

- ps : **현재 실행 중인 프로세스(process status)**를 보여주는 명령어

- -e : **모든 사용자(all users)**의 모든 프로세스를 보여줘

  (== -A와 같음)

- -f : **full format** 출력, 즉 **자세한 정보**를 보여줘

```
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 Apr28 ?        00:00:04 /sbin/init
user      2480  2345  0 10:12 pts/0    00:00:00 bash
user      2533  2480  0 10:13 pts/0    00:00:00 ps -ef
```

<br>

| **컬럼 약어** | **뜻 (설명)**                 | **Full Name**     |
| ------------- | ----------------------------- | ----------------- |
| **UID**       | 프로세스를 실행한 사용자 이름 | User ID           |
| **PID**       | 프로세스 ID                   | Process ID        |
| **PPID**      | 부모 프로세스의 ID            | Parent Process ID |
| **C**         | CPU 사용률 (최근 CPU 사용량)  | CPU Usage         |
| **STIME**     | 프로세스 시작 시간            | Start Time        |
| **TTY**       | 프로세스가 연결된 터미널      | Teletype Terminal |
| **TIME**      | 누적 CPU 사용 시간            | CPU Time          |
| **CMD**       | 실행된 명령어 전체            | Command           |

<br>

### b) Foreground 프로세스 vs. Background 프로세스

프로그래머가 명령어 입력 후 ...

- 기다리며 결과를 확인하려면 **프로그라운드**,
- 백그라운드에서 돌아가게 하고 싶으면 & 붙여서 **백그라운드 프로세스**로 실행

| **구분**        | **프로그라운드 프로세스 (Foreground Process)** | **백그라운드 프로세스 (Background Process)**           |
| --------------- | ---------------------------------------------- | ------------------------------------------------------ |
| **실행 방식**   | 사용자가 직접 터미널에서 실행                  | 터미널과 분리되어 백그라운드에서 실행                  |
| **터미널 점유** | 터미널을 점유하고 입력을 기다림                | 터미널을 점유하지 않음                                 |
| **종료 방식**   | 사용자가 명시적으로 종료하거나 자동 종료       | 자동 실행되거나 명시적 종료 필요                       |
| **실행 예시**   | python script.py                               | python script.py &                                     |
| **제어 가능성** | 입력/출력 제어 가능                            | 직접적인 제어 어려움 (제어하려면 jobs, fg, bg 등 사용) |

<br>

### c) 프로세스 제어 블록, Process Control Block (PCB)

![figure2](/assets/img/cs/img81.png)

![figure2](/assets/img/cs/img82.png)

PCB란?

- **프로세스의 ‘신분증 + 현재 상태 + 자원 정보’**를 담은 핵심 데이터 구조
- 운영체제는 PCB를 통해서 프로세스를 관리/전환 함

<br>

PCB의 주요 항목들:

| **항목**             | **설명**                                                     |
| -------------------- | ------------------------------------------------------------ |
| **PID / PPID**       | **PID**는 프로세스 고유 ID, **PPID**는 부모 프로세스의 ID야  |
| **레지스터**         | 프로세스 실행 중 사용하던 **CPU 레지스터 값**들을 저장 (예: PC, SP 등) |
| **스케줄링 정보**    | 우선순위, 상태, 스케줄 큐 위치 등 **CPU 스케줄러가 사용하는 정보** |
| **메모리 정보**      | 코드, 데이터, 힙, 스택 등 **프로세스가 사용하는 메모리 영역 정보**를 담고 있음 |
| **사용한 파일 정보** | 열려 있는 파일의 리스트 (파일 디스크립터 등)를 포함          |
| **입출력장치 정보**  | 어떤 입출력 장치(예: 키보드, 프린터)를 사용하는지, 버퍼 상태 등 |

<br>

예시) 

**PID가 3254라는 문자열을 포함하는 프로세스를 찾기 위해** 사용하는 명령어

```bash
ps aux | grep 3254
```

각 옵션의 의미:

| **옵션** | **의미**                                              |
| -------- | ----------------------------------------------------- |
| a        | **다른 사용자**의 프로세스도 포함                     |
| u        | **사용자 중심의 포맷**으로 (UID, CPU, MEM 등 포함)    |
| x        | 터미널과 연결되지 않은 **백그라운드 프로세스**도 포함 |

<br>

PID가 **정확히 3254인 프로세스**를 찾고 싶다면:

```bash
ps -p 3254
```

<br>

프로세스 실행이 종료되면, PCB는 폐기됨!

<br>

## (2) 문맥 교환

### a) 문맥교환 (Context Switch)

- 운영체제가 **현재 실행 중인 프로세스(또는 스레드)를 중단**하고, **다른 프로세스로 전환**하는 과정

![figure2](/assets/img/cs/img83.png)

![figure2](/assets/img/cs/img84.png)

<br>

### b) 문맥 교환 과정

- CPU가 한 번에 하나의 작업(프로세스)만 처리할 수 있으니까, 여러 작업을 **빠르게 번갈아가며 처리**해야함
- 이때 작업을 바꿀 때마다 **“이전 작업의 상태를 저장하고, 다음 작업의 상태를 복원”** 해야함

$$\rightarrow$$ 이 과정 전체가 **문맥(context)을 교환**하는 것!

<br>

교환되는 정보?

- 운영체제는 이전 작업의 상태를 PCB에 저장하고, 새 작업의 PCB에서 정보를 불러옴

| **저장/복원되는 정보** | **예시**                                       |
| ---------------------- | ---------------------------------------------- |
| 레지스터 값            | 일반 레지스터, 스택 포인터, 프로그램 카운터 등 |
| 메모리 매핑 정보       | 어떤 메모리 영역을 사용하는지                  |
| 프로세스 상태          | 준비, 실행, 대기 중 등                         |
| CPU 상태               | 인터럽트 마스크, 플래그 등                     |

<br>

### c) 예시

1. **사용자 A의 워드 프로세서** 실행 중
2. **알람 앱이 울려야 해서**, OS가 워드 프로세서 중단
3. OS는 워드 프로세서의 상태를 저장 (PCB)
4. OS는 알람 앱의 상태를 불러와 실행
5. 알람 끝나면, 다시 워드 프로세서의 상태를 복원

<br>

### d) 참고 사항

문맥교환은 **시간과 자원을 소모**한다!

( $$\because$$ 저장/복원 작업이 메모리와 CPU 레벨에서 꽤 복잡 )

$$\rightarrow$$ OS는 **불필요한 문맥교환을 줄이도록** 설계되어 있음!

<br>

## (3) 사용자 영역

- **코드 영역 (텍스트 영역)**
  - 실행 가능한 코드
  - 기계어로 이루어진 명령어
  - Read-only
- **데이터 영역**
  - 프로그램이 실행되는 동안 유지되는 데이터 (e.g., 전역 변수)
- **힙 영역**
  - 사용자(개발자)가 직접 할당 가능한 공간
  - *메모리 영역을 할당했따면, 해제하자!*
    - 직접 해제하기, 자동으로 해제하기 (Garbage collection)
- **스택 영역**
  - 임시로 저장되는 영역 (e.g., 매개 변수, 지역 변수)

<br>

힙 vs. 스택

- 힙: 낮은 주소에서 높은 주소로 할당
- 스택: 높은 주소에서 낮은 주소로 할당

$$\rightarrow$$ for 주소 중복 방지

<br>

## (4) 프로세스 생성과 상태

### a) 대표적인 프로세스 상태

1. 생성 (new)
2. 준비 (ready)
3. 실행 (running)
4. 대기 (blocked)
5. 종료 (terminated)

<br>

![figure2](/assets/img/cs/img85.png)

<br>

확인하는 방법?

```
top
```

```
  PID USER     PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
 3254 alice    20   0  164728   9268   7852 R  12.5  0.3   0:01.23 python
 3255 alice    20   0   45632   3020   2556 S   0.0  0.1   0:00.01 bash
```

<br>

위의 `S` (STATE) 또는 STAT 열에 나타남

| **상태 코드** | **의미**                   | **설명**                                       |
| ------------- | -------------------------- | ---------------------------------------------- |
| R             | Running                    | 현재 CPU에서 실행 중 (running or ready)        |
| S             | Sleeping (Interruptible)   | 대기 상태 (입출력 등 이벤트 기다리는 중)       |
| D             | Sleeping (Uninterruptible) | 강제로 깨울 수 없는 대기 (디스크 IO 등)        |
| T             | Stopped                    | 일시 중지됨 (예: Ctrl+Z)                       |
| Z             | Zombie                     | 자식 프로세스 종료 후 부모가 수거하지 않음     |
| I             | Idle                       | kernel thread이며 유휴 상태 (Linux 5.10+ 기준) |

<br>

### b) 프로세스의 계층적 구조

![figure2](/assets/img/cs/img86.png)

<br>

## (5) 스레드

(소프트웨어의) 스레드란?

$$\rightarrow$$ 프로세스를 구성한 **실행 흐름의 단위**

![figure2](/assets/img/cs/img87.png)

<br>

### a) 프로세스 vs. 스레드

3개의 프로세스 vs. 1개의 프로세스 내의 3개의 스레드

![figure2](/assets/img/cs/img88.png)

<br>

주된 차이점? ***자원 공유***의 여부

- 프로세스 간에는 (기본적으로) 자원 공유 X
- 스레드 간에는 자원 공유 O

![figure2](/assets/img/cs/img89.png)

![figure2](/assets/img/cs/img90.png)

<br>

앞서 말했듯, "기본적으로는" 공유하지 않지만,

***프로세스 간에도 자원 공유는 가능하다!***

$$\rightarrow$$ **IPC (Inter-Process Communication), 프로세스 간 통신**

<br>

### b) IPC (Inter-Process Communication)

- **"공유 메모리"**를 통한 통신
- **"파이프"**를 통한 통신
- **"네트워크 소켓"**를 통한 통신

![figure2](/assets/img/cs/img91.png)

<br>

## (6) 멀티 프로세스 & 멀티 스레드

| **항목**    | **멀티 프로세스**                         | **멀티 스레드**                                          |
| ----------- | ----------------------------------------- | -------------------------------------------------------- |
| 정의        | 여러 개의 독립된 프로세스가 동시에 실행   | 하나의 프로세스 내에서 여러 스레드가 실행                |
| 메모리 공간 | 각 프로세스는 독립된 메모리 공간을 가짐   | 메모리 공간(코드, 데이터 등)을 공유                      |
| 통신 방식   | 느린 IPC (예: 파이프, 소켓 등) 필요       | 빠른 공유 메모리 사용 가능                               |
| 안정성      | 하나가 죽어도 다른 프로세스에는 영향 없음 | 하나의 스레드 오류가 전체 프로세스에 영향 줄 수 있음     |
| 생성 비용   | 상대적으로 큼                             | 상대적으로 작음                                          |
| 예시        | 웹 브라우저의 탭별 독립 실행              | 게임에서 동시에 실행되는 물리엔진, 렌더링, 사운드 스레드 |

요약

- **멀티 프로세스의 focus: 독립성, 안정성**
- **멀티 스레드의 focus: 자원 공유, 속도**
