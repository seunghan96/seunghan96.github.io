---
title: 3-3) 네트워크 - 네트워크 계층 (part 1)
categories: [CS]
tags: []
excerpt: 
---

<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

(참고: Fastcampus 강의, 강민철의 인공지능 시대 필수 컴퓨터 공학 지식)

# 3. 네트워크 계층 (part 1)

## Contents

1. IP
1. ARP
1. ICMP

<br>

## (1) IP

### a)  **네트워크 계층**

(지난 시간까지) 물리 계층 + 데이터링크 계층:

$$\rightarrow$$ ***"LAN에 국한"***된 통신이었다!

<br>

Q) *LAN을 넘어서기 위한 계층은?* (i.e., 네트워크 "간" 통신이 가능한 계층은?)

$$\rightarrow$$ ***네트워크 계층***

- 라우팅: **다른 네트워크끼리 통신할 수 있도록**, 데이터가 **어떤 경로로 전달될지 결정하는 과정**

<br>

### b) IP 주소 (& MAC 주소)

네트워크 "간"의 통신을 위해서는 IP 주소가 필요하다.

$$\rightarrow$$ Q) MAC 주소가 있지 않나?

<br>

MAC 주소만을 이용할 경우?

- (1) 도달 경로 파악 어려움 (라우팅 어려움)
- (2) 세상에 기기는 매우 많음 .... 임의의 네트워크에 속한 호스트의 MAC주소를 기억하기 어려움!

$$\rightarrow$$ **IP 주소 (선) + MAC 주소 (후) 함께 사용!**

- (택배 비유) IP 주소 = 수신 주소, MAC 주소 = 수신인

![figure2](/assets/img/cs/img154.png)

<br>

IP 주소 vs. MAC 주소

- **MAC 주소**는 **네트워크 카드에 하드웨어적으로 부여된 고유 주소**
  - 수취인의 개인 정보 (e.g., 주민번호) $$\rightarrow$$ 물리 주소
- **IP 주소**는 **네트워크에서 통신을 위해 사용하는 논리적인 주소**
  - 수취인의 주소 $$\rightarrow$$ 논리 주소

<br>

(기본적으로) 기기를 찾는 데에 있어서, 우선적으로 "IP 주소"하고, 그 뒤에 "MAC 주소"를 활용한다

<br>

### c) IP 주소 할당 방식

1. **직접 할당 (Static IP)**
   - 사용자가 수동으로 IP 주소를 지정 (예: 서버 설정 시).
2. **자동 할당 (DHCP: Dynamic Host Configuration Protocol)**
   - 공유기나 DHCP 서버가 자동으로 IP 주소를 클라이언트에게 부여
   - 이때, 클라이언트는 자신의 **MAC 주소를 DHCP 서버에 알리고** IP를 요청

<br>

### d) IP의 2가지 주요 기능

| **기능**            | **설명**                                          |
| ------------------- | ------------------------------------------------- |
| 1. **IP 주소 지정** | 장치 간 통신을 위한 "고유 식별자" 제공            |
| 2. **단편화**       | 큰 데이터를 "작은 단위로 나누어" 전송 가능하게 함 |

<br>

단편화란?

- 데이터가 **MTU(Maximum Transmission Unit)**보다 클 경우, 이를 **작은 조각(프래그먼트)**으로 나누어 전송
- 단편화는 **IP 계층에서 수행되며**, 목적지에서 다시 조립

$$\rightarrow$$ 큰 데이터를 효율적으로 전달할 수 있도록 만듬!

<br>

### e) IPv4 헤더

![figure2](/assets/img/cs/img155.png)

<br>

| **필드 이름**  | **설명**                                                     |
| -------------- | ------------------------------------------------------------ |
| 송신지 IP 주소 | 발신자의 IP                                                  |
| 목적지 IP 주소 | 수신자의 IP                                                  |
| 식별자         | 단편 식별용 고유 번호                                        |
| 플래그         | 단편화 여부 및 상태 지정                                     |
| 단편화 오프셋  | 원본 데이터에서의 위치                                       |
| TTL            | 무한 루프 방지를 위한 수명                                   |
| 프로토콜       | IP 패킷 내 데이터가 어느 상위 계층 프로토콜로 전달되어야 하는지 지정 |

(3~5는, 단편화 관련된 필드임)

1. **송신지 IP 주소 (Source IP Address)**
   - 패킷을 보낸 **발신자의 IP 주소**

2. **목적지 IP 주소 (Destination IP Address)**
   - 패킷이 **도착해야 할 최종 목적지**의 IP 주소

3. **식별자 (Identification)**

   - 하나의 원래 패킷에서 생성된 모든 단편이 **같은 값**을 가짐

   - 수신 측에서 여러 조각을 다시 하나의 패킷으로 **조립**할 때 사용

4. **플래그 (Flags)**
   - 단편화 동작을 제어하는 **3비트 필드**입니다.
     - 0: 예약 (사용하지 않음)
     - 1: Don’t Fragment (DF) – 단편화 금지
     - 2: More Fragments (MF) – 뒤에 더 많은 조각이 있음

5. **단편화 오프셋 (Fragment Offset)**

   - 해당 단편이 원래 데이터의 **어디서부터 시작하는지**를 바이트 단위로 나타냄

   - 단편의 **순서 지정** 및 **재조합**에 사

6. **TTL (Time To Live)**

   - **목적:** 패킷이 네트워크를 지나며 지나칠 수 있는 최대 라우터(홉) 수를 제한하는 역할

     ( for 무한 루프 방지, 네트워크 자원 낭비 방지 )

   - **동작:** 패킷이 라우터를 지날 때마다 TTL 값이 1씩 감소

     → TTL이 0이 되면 해당 패킷은 폐기되고 송신자에게 ICMP “Time Exceeded” 메시지가 전송됨

7. **프로토콜 (Protocol)**

   - **목적:** (IP 패킷 내 데이터가) 어느 상위 계층 프로토콜로 전달되어야 하는지 지정

   - **예:**
     - 6 → TCP (Transmission Control Protocol)
     - 17 → UDP (User Datagram Protocol)
     - 1 → ICMP (Internet Control Message Protocol)

<br>

### f) IPv4 vs. IPv6

IPv4

- 4바이트 (32비트)로 표현 가능

- 한 옥텟은 0~255 범위의 네 개의 십진수로 표기

  $$\rightarrow$$ 이론적으로 할당 가능한 IPv4 주소 개수 == $$2^{32}$$개

<br>

IPv6

- IPv4의 IP 수 부족문제 해결 위해 등장

- 16바이트 (128비트)로 표현 가능

  $$\rightarrow$$ 이론적으로 할당 가능한 IPv4 주소 개수 == $$2^{128}$$개

<br>

## (2) ARP (Address Resolution Protocol)

(복습: *기본적으로 MAC 주소 이전에*  **IP 주소**를 사용)

<br>

### a) ARP란?

ARP =  ***IP 주소를 통해 MAC 주소를***  알아내기 위한 프로토콜

( **동일 네트워크 내의** 호스트의 MAC 주소를 알아내기 위한 프로토콜 )

<br>

### b) ARP 동작 과정

- Step 1) ARP 요청
- Step 2) ARP 응답
- Step 3) ARP 테이블 갱신

<br>

**Step 1) ARP 요청 (= Broadcast 메세지)**

- For 특정 IP 주소를 가진 호스트의 MAC 주소를 알기 위해!
- 해당 호스트의 MAC 주소를 모르기 때문에, Broadcast 메세지로 보냄

![figure2](/assets/img/cs/img156.png)

<br>

**Step 2) ARP 응답**

- ARP 요청 메세지에 대한 응답
- **자신의 MAC 주소**를 포함해서 응답함

![figure2](/assets/img/cs/img157.png)

<br>

**Step 3) ARP 테이블 갱신**

- ARP 테이블 (ARP 캐시): MAC 주소 & IP 주소의 매핑 table
  - 일정 시간이 지나면 삭제
- ARP 테이블에 추가가된 호스트는, Broadcast로 ARP 요청을 보낼 필요가 없음.

![figure2](/assets/img/cs/img158.png)

<br>

Question) **"같은 (X) 다른 (O)" 네트워크**에 속한 호스트의 MAC 주소는 어떻게 알아내지?

Answer) ***"Router"***

<br>

## (3) ICMP

### a) IP의 한계점

- (1) **비신뢰성**: 패킷이 목적지까지 잘 전송된다는 보장 X
- (2) **비연결형**: 호스트 간의 사전 연결 수립이 X

<br>

### c) IP vs. TCP

**IP (Internet Protocol)**

- **계층:** 네트워크 계층
- **역할:** 데이터를 목적지까지 전달하는 **기본적인 경로 제공**
- **특징:** 비신뢰성 & 비연결형

$$\rightarrow$$ 즉, IP는 “최선을 다해서” 전달만 할 뿐, **전송이 제대로 되었는지 확인하지 않음**.



**TCP (Transmission Control Protocol)**

- **계층:** 전송 계층
- **역할:** 애플리케이션 간 **신뢰성 있는 통신**을 보장
- **특징:**
  - **신뢰성 (Reliable)**: 패킷 손실, 순서 뒤바뀜 등을 감지하고 복구
  - **연결형 (Connection-oriented)**: 통신 전에 연결을 설정 (3-way handshake)
  - **흐름 제어**, **혼잡 제어**, **재전송**, **에러 체크** 등의 기능 포함

<br>

| **항목**    | **IP (네트워크 계층)**      | **TCP (전송 계층)**                    |
| ----------- | --------------------------- | -------------------------------------- |
| 연결 방식   | 비연결형 (Connectionless)   | 연결형 (Connection-oriented)           |
| 신뢰성      | 보장하지 않음               | 보장함                                 |
| 데이터 순서 | 보장하지 않음               | 순서를 보장함                          |
| 오류 처리   | 없음                        | 재전송, 오류 감지, 복구 가능           |
| 목적        | 데이터가 어디로 가야 하는지 | 데이터가 **어떻게 정확히** 가야 하는지 |

<br>

### c) ICMP (Internet Control Message Protocol)

- IP와 마찬가지로 네트워크 계층 프로토콜!
- 정확히는, **IP의 일부**이다!

- 목적: IP의 위의 한계점 보완 (극복은 아님)
  - 데이터를 전송하는 것이 아니라, **오류 알림, 상태 정보 전달** 등의 **제어 메시지**를 주고받는 데 사용

![figure2](/assets/img/cs/img159.png)

<br>

### d) ICMP의 주요 기능

1. **오류 알림 (Error Reporting)**
   - 목적지에 도달할 수 없을 때
   - TTL(Time to Live)이 0이 되었을 때
   - 포트가 열려있지 않을 때 등
2. **네트워크 진단 (Network Diagnostics)**
   - 네트워크가 정상적으로 동작하는지 확인

<br>

대표적인 메세지 유형

( ICMP 메세지는 타입 & 코드로 정의 )

![figure2](/assets/img/cs/img159.png)

<br>

Note that "IP의 한계를 보완할 뿐, 완전히 해결은 아님!"

$$\rightarrow$$ 근본적인 해결책은, 위의 b)에서 말한 "전송 계층"에서 이루어짐!

<br>

## (4) IP 주소

### a) MAC 주소 vs. IP 주소

IP 주소의 구성: **(1) 네트워크 주소 + (2) 호스트 주소**

- 비트 수 고정 X 

![figure2](/assets/img/cs/img161.png)

<br>

MAC 주소의 구성: **(1) 제조사 번호 + (2) 일련 번호**

- 비트 수 고정 O ( (1) = 24 비트 + (2) = 24 비트 )

![figure2](/assets/img/cs/img162.png)

<br>

### b) 클래스풀 (Classful) 주소 체계

클래스풀 주소는 IP 주소를 **고정된 크기의 네트워크/호스트 비트로 구분**하던 방식 

| **클래스** | **시작 IP 범위**            | **서브넷 마스크**               | **호스트 수** |
| ---------- | --------------------------- | ------------------------------- | ------------- |
| A          | 0.0.0.0 ~ 127.255.255.255   | 255.0.0.0 (8비트 네트워크)      | 약 1,670만 개 |
| B          | 128.0.0.0 ~ 191.255.255.255 | 255.255.0.0 (16비트 네트워크)   | 약 6만 5천 개 |
| C          | 192.0.0.0 ~ 223.255.255.255 | 255.255.255.0 (24비트 네트워크) | 254개         |

![figure2](/assets/img/cs/img163.png)

<br>

예시) A 클래스

![figure2](/assets/img/cs/img164.png)

<br>

### c) 고정된 주소

최소 & 최대값은 각각 특별한 의미를 가짐! 부여 불가!

![figure2](/assets/img/cs/img165.png)

$$\rightarrow$$ 즉, 이 중 **호스트 ID가 전부 0이거나 전부 1인 경우는 특별한 의미**로 쓰여서 **일반 호스트에게 할당할 수 없음**



**호스트 ID가 전부 0 → 네트워크 주소**

- **해당 네트워크 자체를 식별**하는 데 사용
- 예: 192.168.1.0 (클래스 C)

**호스트 ID가 전부 1 → 브로드캐스트 주소**

- **그 네트워크에 속한 모든 호스트에게 패킷을 전송**하는 데 사용
- 예: 192.168.1.255 (클래스 C)

<br>

요약

| **구분**       | **의미**                           | **사용 가능 여부** |
| -------------- | ---------------------------------- | ------------------ |
| 최소값 (all 0) | 네트워크 주소                      | ❌                  |
| 최대값 (all 1) | 브로드캐스트 주소                  | ❌                  |
| 나머지 주소    | 실제 호스트에 부여 가능 (1~254 등) | ✅                  |

<br>

### d) 클래스리스 (Classless) 주소 체계

- 클래스풀 주소 체계보다 **더 정교히 네트워크를 나누는 방법**
- 오늘날 주로 사용하는 방식
- 네트워크와 호스트를 구분하기 위해  **서브넷 마스크** 이용

![figure2](/assets/img/cs/img166.png)

<br>

### e) 서브넷 마스크 (Subnet Mask)

IP 주소에서 **네트워크 부분과 호스트 부분을 구분**하는 데 사용하는 **32비트 숫자**

- IP 주소는 32비트 (4바이트)
- 서브넷 마스크도 32비트
- 둘은 **비트 단위로 AND 연산**되어, IP가 속한 **네트워크 주소**를 구함



Example)

- IP 주소: 192.168.1.10

- 서브넷 마스크: 255.255.255.0 → 이진: 11111111.11111111.11111111.00000000

- 해석

  - **앞의 24비트**는 네트워크 주소 (192.168.1)

  - **뒤의 8비트**는 호스트 주소 (.10)

<br>

자주 사용되는 서브넷 마스크

| **서브넷 마스크** | **CIDR 표기** | **호스트 개수 (이론상)** | **설명**                   |
| ----------------- | ------------- | ------------------------ | -------------------------- |
| 255.0.0.0         | /8            | 약 1,670만 개            | 클래스 A (대규모 네트워크) |
| 255.255.0.0       | /16           | 65,534개                 | 클래스 B                   |
| 255.255.255.0     | /24           | 254개                    | 클래스 C                   |
| 255.255.255.192   | /26           | 62개                     | 서브넷 분할 예시           |

- 호스트 개수 = $$2^{호스트비트}  - 2$$ (네트워크 주소와 브로드캐스트 주소 제외)

<br>

동작 원리 (AND 연산)

- ex) 192.168.1.10 AND 255.255.255.0

```
IP:       11000000.10101000.00000001.00001010 (192.168.1.10)
Mask:     11111111.11111111.11111111.00000000 (255.255.255.0)
----------------------------------------------------------
Network:  11000000.10101000.00000001.00000000 (192.168.1.0)
```

→ 결과: **192.168.1.0** → 이게 이 호스트가 속한 네트워크

<br>
