---
title: \[Java 기초\] 10.클래스 이용
categories: [JAVA]
tags: [Java]
excerpt: 그림으로 배우는 Java Programming Basic

---

<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

# 10. 클래스 이용

## 10-1. 클래스 라이브러리

처음부터 직접 만들 필요 X

Java의 표준 개발환경인 JDK에는 **클래스 라이브러리**라는 많은 클래스들이 포함되어 있음

ex)

```
IOException
BufferedReader
InputStreamReader
System
String
Integer
...
```

<br>

해당 클래스에서, 다음과 같은 변수를 선언하여 사용하고 있음

```
br : Buffered Reader 클래스의 변수
str : String 클래스의 변수

br.readLine() : BufferedReader 클래스의 "인스턴스 메소드"
Integer.parseInt(str) : Integer 클래스의 "클래스 메소드"
```

<br>

## 10-2. 문자열 처리 클래스

대표적인 클래스 : **String 클래스**

주요 메소드

```
charAt, endsWith,.....
```

<br>

### charAt() & length() 메소드

```java
String str="Hello";
char ch1=str.charAt(0);
char ch2=str.charAt(1);
int len = str.length();
```

<br>

### 문자열 객체 생성 시, 주의점

객체 생성 시, "new" 연산자를 사용?

```java
// new 사용 O
String str = new String("Hello");

// new 사용 X
String str = "Hello";
```

<br>

### 대&소문자

```java
String str="Hello";
string str_U = str.toUpperCase();
string str_L = str.toLowerCase();
```

<br>

### 문자 검색

```java
String str = br.readLine();

char ch=str.charAt(0);
int num = str.indexOf(ch);
```

<br>

### 문자열 추가하기

`StringBuffer 클래스`

```java
String str = br.readLine();

StringBuffer sb = new StringBuffer(str);
sb.append(str2);
```

<br>

## 10-3. 기타 클래스

### Integer 클래스

주요 메소드

```
static int parseInt(String s)
static Integer valueOf(String s)
```

example

```java
string str = br.readLine();
int num = Integer.parseInt(str);
```

<br>

### Math 클래스

주요 메소드

```
static double abs(double a)
static int abs(int a)
static double ceil(double a)
...
```

example

```java
int ans = Math.max(num1,num2);
```

question : 주사위 1~6사이 정수값

```java
int num (int) (Math.random()*6)+1;
```

<br>

## 10-4. 클래스 형 변수

### 클래스 형 변수에 대입하기

Car형 변수

```java
Car car1;
car1 = new Car();
```

<br>
대입하기

```java
class Sample
{
    public static void main(String[] args)
    {
        // .....
        Car car1;
		car1 = new Car();
        set1.setCar(1234,20.5);
        
        Car car2;
        car2 = car1;
        // .....
    }
}
```

- 이 둘은 "서로 같은 객체"를 나타낸다!
- 대입 받은 변수가, 대입하는 변수를 "가리키는 것 뿐"!

<br>

### null의 원리

그 변수는, 객체를 가리키기 못하게 됨!

<br>

### 메소드의 인수로서 사용

```java
class Car
{
    // 기본형 변수를 사용한 필드
    private int num;
    private double gas;
    
    // 클래스형 변수를 사용한 필드
    private String name;
    
    // 중략
    public void setCar(int n, double g)
    {
        //..
    }
    
    public void setName(String nm)
    {
        //..
    }
}
```

```java
class Sample
{
    public static void main(String[] args)
    {
        Car car1;
        car1 = new Car();
        car1.show();
        
        int number = 1234;
        double gasoline = 20.5;
        String str = '1호차';
        
        car1.setCar(number,gasoline);
        car1.setName(str);
        car1.show()
    }
}
```

<br>

### 값의 전달 & 참조의 전달

클래스형 변수

- 참조의 전달

  ( = 호출한 곳에서 가리키는 객체와, 호출된 곳에서 가리키는 객체는 같다 )

값의 전달

- 값의 전달

  ( = ~ 다르다 )

<r>

## 10-5. 객체 배열

```java
class Sample
{
    public static void main(String[] args)
    {
        // 배열 준비
        Car[] cars;
        cars = new Car[3];
        
        // 배열에 요소 대입
        for(int i=0;i<cars.length; i++){
            cars[i] = new Car();
        }
    }
    
    // 생략
}
```



# 11. 새로운 클래스

## 11-1. 상속

**이미 설계된 class를 바탕으로**, 새로운 class를 만들 수 있도록!

- "class를 확장한다" (extend)
- 기존 class의 멤버를 "물려받아", "새로운 필요한 성질/기능"을 추가한다!

<br>

용어

- 슈퍼 클래스 : 바탕이 되는 클래스
- 서브 클래스 : 새로운 클래스

<br>

### 클래스 확장하기

- 슈퍼 클래스 : Car
- 서브 클래스 : RacingCar
  - 굳이 물려받은 멤버 따로 작성 필요 X
  - Car에 없는 고유한 멤버만 추가하면 됨
    - 아래의 ex) course 필드 & setCourse() 메소드

```java
class RacingCar extends Car
{
    // 추가되는 고유의 필드
    private int course;
    
    // 서브클래스의 생성자
    public RacingCar()
    {
        course=0;
        System.out.println("레이싱카 생성");
    }
    
    // 추가되는 고유의 메소드
    public void setCourse(int c)
    {
        course = c;
        System.out.println("코스 번호를"+course+"로 설정")
    }
}
```

<br>

### 서브 클래스의 객체 생성

- 객체 생성 방식은 동일! `new` 사용

```java
class Sample1
{
    public static void main(String[] args)
    {
        RacingCar rccar1;
        rccar1 = new RacingCar();
        
        rccar1.setCar(1234,10.5); // 상속받은 메소드
        rccar1.setCourse(5); // 고유한 메소드
    }
}
```

<br>

### 클래스의 기능

Java의 클래스가 가진 3가지 강점

- 상속
- 캡슐화
- 다형성

<br>

### 슈퍼 클래스의 생성자 호출

순서

- 1) **슈퍼 클래스**의 생성자 호출
- 2) **서브 클래스**의 생성자 호출

슈퍼클래스의 생성자는, 서브 클래스에게 상속 X.

( 대신, 슈퍼클래스의 "인수 없는" 생성자가 자동으로 호출됨 )

<br>

### 슈퍼 클래스의 생성자 지정 .. `super()`

BUT, 슈퍼 클래스가 "여러 개의 생성자"를 가질 수 있음

- 명시적으로 지정하기 위해서는? `super()` 사용하기!

example)

```java
class Car
{
    public Car()
    {
        //중략
    }
    
    public Car(int n, double g)
    {
        //중략
    }
}
```

```java
class RacingCar extends Car
{
    // [ 생성자 1 ]
    public RacingCar()
    {
        course=0;
        System.out.println("레이싱카 생성");
    }
    
    // [ 생성자 2 ]
    public RacingCar(int n, double g, int c)
    {
        super(n,g); // 슈퍼클래스의 여러 생성자 중, 인자를 2개 받는 생성자 호출!
        course = c;
        System.out.println("코스번호가 "+cousre+"인 레이싱카 생성");
    }
    
    // 중략
}
```

```java
class Sample
{
    public static void main(String[] args)
    {
        // 서브 클래스의 여러 생성자 중, 인자를 3개 받는 생성자 호출!
        RacingCar rccar1 = new RacingCar(1234,20.5,5);
    }
}
```

<br>

### this vs super

- `this` : 그 클래스의 다른 생성자 호출
- `super` : 슈퍼 클래스의 생성자 호출

<br>

## 11-2. 멤버에 접근하기

### 서브 클래스 안에서 접근하기

클래스를 상속 받았을 때, 캡슐화가 어떻게 구현? ( private )

***"서브 클래스 조차도" 접근 불가***

접근하기 위해선, private 대신 **protected** 사용해야!

```java
class Car
{
    protected int num;
    protected double gas;
    // 생략
}
```

<br>

## 11-3. 오버라이딩

### '메소드'를 오버라이딩하기

슈퍼클래스와 "완전히 동일한 메소드"도 선언할 수 있음!

- **덮어쓰기! (overriding)**

<br>

example

```java
class Car
{
    // 중략
    
    // 슈퍼 클래스의 show() 메소드
    public void show()
    {
        System.out.println("차량 번호는" +num);
        System.out.println("연료 양은"+gas);
    }
}
```

```java
class RacingCar extends Car
{
    // 중략
    
    // 서브 클래스의 show() 메소드
    public void show()
    {
        System.out.println("레이싱카 차량 변호는 "+num);
        System.out.println("연료 양은"+gas);
        System.out.println("코스 번호는"+course);
    }
}
```

<br>

위와 같은 상황에서, `show()`메소드를 호출하면

- ***"서브 클래스"의 show() 메소드가 호출된다***

<br>

### 슈퍼 클래스의 변수로 객체 다루기

아래와 같이도 가능하다!

( 서브 클래스 객체가, 슈퍼 클래스의 객체이기도 하므로 )

```java
Car car1;
car1 = new RacingCar();
```

위와 같은 상황에서, `show()`메소드를 호출하면

- 마찬가지로 ***"서브 클래스"의 show() 메소드가 호출된다***

  ( 객체를 가리키는 변수의 클래스와 상관 없이, 객체 자신의 클래스에 따라 적절한 메소드 수행! )

- 다만, `setCourse()`와 같은 서브 클래스의 고유 메소드는 이용 X

<br>

### 오버라이딩의 중요성

슈퍼 클래스의 배열 이용하기

```java
class Sample6
{
    public static void main(String[] args)
    {
        // 슈퍼클래스 array 생성
        Car[] cars;
        cars = new Car[2];
        
        // (1) 슈퍼 클래스 객체 생성
        cars[0] = new Car();
        cars[0].setCar(1234,20.5);
        
        // (2) 서브 클래스 객체 생성
        cars[1] = new RacingCar();
        cars[1].setCar(4567,30.5);
        
        // (1),(2) 모두 동일한 슈퍼클래스 배열로 다룰 수 있다!
        for(int i=0; i<cars.length; i++){
            // (1)은 슈퍼 클래스의 show()메소드
            // (2)는 서브 클래스의 show()메소드
            cars[i].show();
        }
    }
}
```

<br>

### 오버라이딩 vs 오버로딩

오바리이딩

- 서브 클래스에서 이름/인수의 형/인수의 개수까지 모두 같은 슈퍼클래스의 메소드와 **"동일한 메소드"를 정의해서 덮어쓰기**

오버로딩

- **메소드의 이름은 같지만**, 인수의형/인수의 개수가 다른 메소드를 정의하는 것

<br>

### 슈퍼 클래스와 같은 이름의 멤버 사용

- 앞에 `super.`를 붙인 뒤 호출하면, 슈퍼클래스의 메소드를 호출!
- 메소드 뿐만 아니라, 필드 앞에도 OK

메소드 ex)

```java
class RacingCar extends Car
{
    public void show()
    {
        // (선) 슈퍼 클래스의 show()
        super.show();
        // (후) 서브 클래스의 show()
        System.out.println("코스 번호는"+course);
    }
}
```

<br>

필드 ex)

```java
class Car
{
    int x;
    ...
}

class RacingCar extends Car
{
    int x;
    //...
    
    public void show()
    {
        x=10; // 서브 클래스의 필드
        super.x=20; // 슈퍼 클래스의 필드
    }
}
```

<br>

### final

메소드 이름 앞에 `final`을 붙일 경우, **오버라이딩 불가**

```java
class Car
{
    public final void show(){
        // final을 붙였다
    }
        
}

class RacingCar extends Car
{
    // overriding 불가능! 
    //--------------------------------
    /*public final void show() 
    {
       
    }*/
    //--------------------------------
}
```

<br>

**서브 클래스 자체**를 만들 수 없는 클래스를 설계해야 할 때!

```java
final class Car
{

}
```

<br>

메소드, 클래스 뿐만 아니라, **필드** 앞에 붙일수도 있다!

( = 상수(constant) )

```java
class Car
{
    static final int NUM_TIRE=4;
}
```

<br>

## 11-4. Object 클래스의 상속

- Object = 모든 클래스의 근원이 되는 class

- 슈퍼 클래스 - 서브 클래스 - 서브 서브 클래스 - ....

- 하나의 클래스가 **여러 슈퍼 클래스로부터 상속 받을 수 X**

  ( then how...? **"인터페이스"** 사용하기! )

<br>

### Object 클래스의 원리 이해하기

슈퍼 클래스를 지정하지 않으면, default로 **Object class**상속 받음

Object class의 주요 메소드

- `equals(Object obj)`
- `getClass()`
- `toString()`

<br>





# 12. 인터페이스

## 12-1. 추상 클래스

## 12-2. 인터페이스

## 12-3. 클래스 계층



# 13. 대규모 프로개름의 작성

## 13-1. 파일 분할

## 13-2. 패키지의 기본

## 13-3. 패키지의 사용

## 13-4. 임포트





# 14. 예외와 입출력 처리

## 14-1. 예외의 기본

## 14-2. 예외와 클래스

## 14-3. 예외 던지기

## 14-4. 입출력의 기본



# 15. 스레드

## 15-1. 스레드의 기본

## 15-2. 스레드의 상태 변화시키기

## 15-3. 스레드의 생성 방법

## 15-4. 동기화



# 16. 그래픽 어플리케이션

## 16-1. GUI 어플리케이션

## 16-2. 어플리케이션의 응용

## 16-3. Java의 응용과, 앞으로의 학습 계획

​	