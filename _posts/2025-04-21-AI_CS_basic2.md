---
title: 1-2) 컴퓨터 구조 - 명령어
categories: [CS]
tags: []
excerpt: 

---

<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

(참고: Fastcampus 강의, 강민철의 인공지능 시대 필수 컴퓨터 공학 지식)

# Contents

1. 명령어란?
2. 명령어의 구조
3. 주소 지정

<br>

# 2. 컴퓨터 구조 - 명령어

## (1) 명령어란?

### a) 컴퓨터의 이해 능력

- (이해 X) **소스 코드 (source code)**
  - e.g., Python, Java, C/C++..

- (이해 O) **명령어**

$$\rightarrow$$ 따라서, 소스코드는 명령어(+ 데이터)로 변환되어 실행된다!

<br>

### b) 소스 코드 & 명령어

- 소스 코드: 사람(개발자)가 이해하기 편한 언어 ( = 고급 언어 )
- 명령어와 데이터: 컴퓨터가 이해하기 편한 언어 ( = 저급 언어 )

<br>

### c) 저급 언어의 두 종류

- (1) 기계어 (machine code)
  - 2진수 또는 16진수로 직접 CPU가 해석할 수 있는 코드
  - e.g., 10110000 01100001
- (2) 어셈블리어 (assembly language)
  - 기계어의 인간 친화적 표현. 각 명령어는 기계어 한 줄에 대응됨
  - e.g., MOV AL, 61h

<br>

### d) 고급 $$\rightarrow$$ 저급 언어

변환 방식 두 가지

- (1) 컴파일 (compile)
- (2) 인터프리트 (interpret)

<br>

![figure2](/assets/img/cs/img26.png)

| **항목**       | **컴파일 (Compile)**                      | **인터프리트 (Interpret)**                 |
| -------------- | ----------------------------------------- | ------------------------------------------ |
| 실행 방식      | 전체 소스를 한 번에 기계어로 번역 후 실행 | 소스 코드를 한 줄씩 즉시 읽고 실행         |
| 속도           | 실행 속도가 빠름                          | 실행 속도가 상대적으로 느림                |
| 예시 언어      | C, C++, Rust                              | Python, JavaScript, Ruby                   |
| 오류 발견 시점 | 컴파일 시 모든 오류 발견                  | 실행 중 오류 발견                          |
| 결과물         | 독립 실행 파일 (executable) 생성          | 별도 실행 파일 없이 인터프리터가 직접 실행 |

<br>

![figure2](/assets/img/cs/img27.png)

- 대표적인 compiler: gcc, clang, Visual Studio

- 참고) 두 방식은 딱 나뉘는 개념은 아님. 둘의 특성을 모두 갖춘 언어도 있음.

<br>

## (2) 명령어의 구조

명령어 = **(1) 무엇을 대상**으로 **(2) 무엇을 수행**해라

- **(1) 연산코드 (Op-code)**
- **(2) 오퍼랜드 (Operand)**
  - 데이터 혹은 데이터의 위치(=레지스터 이름, 메모리 주소 등)가 명시되기도!

<br>

Examples

- (1) 더해라 & (2) 100과 / 120을

- (2) 빼라 & (2) 메모리 32번지 안의 값과 / 메모리 33번지 안의 값을
- (3) 저장해라 & (2) 120을 / 메모리 128번지에
- (4) 출력해라 & (2) 고양이사진을 / 모니터에

![figure2](/assets/img/cs/img28.png)

<br>

**연산코드**의 종류

- **a) 데이터 전송**: MOVE, STORE, LOAD (FETCH), PUSH, POP
- **b) 산술/논리/연산**: ADD, SUBTRACT / INCREMENT / AND, OR, NOT / COMPARE
- **c) 제어 흐름 변경**: JUMP, CALL, RETURN ..
- **d) 입출력 제어**: READ, WRITE, START IO, TEST IO

<br>

![figure2](/assets/img/cs/img29.png)

<br>

## (3) 주소 지정

오퍼랜드 (operand): 명령어 수행의 **"대상"** 혹은 **"대상의 위치"**

**Why "대상의 위치"?***

- 이유: **명령어의 길이는 한정**이 되어있기 때문에!

![figure2](/assets/img/cs/img30.png)

<br>

**유효 주소**

- 연산 코드에 사용할 데이터 (=연산의 대상이 되는 데이터)가 **"저장된 위치"**

- **주소 지정** = 유효 주소를 찾는 방법
  - CPU마다 차이가 있음

<br>

다섯 가지 "주소 지정" 방법들

- (1) **즉시** 주소 지정 = 데이터를 직접 명시

  - 장) 빠름
  - 단) 데이터 크기에 제한

- (2) **직접** 주소 지정 = 유효 주소 명시

  - 장) 적당히 빠름
  - 단) 메모리 주소 크기에 제한

- (3) **간접** 주소 지정 = 유효 주소의 주소 명시

  - 장) 유효 주소 크기에 제한 없음
  - 단) 느림 (메모리 접근 2번)

- (4) **레지스터** 주소 지정 = 레지스터에 저장

  - 장) 메모리보다 빠름
  - 단) 용량이 넉넉치 않음

- (5) **레지스터 간접** 주소 지정 = 데이터를 메모리에 저장 & 유효주소를 레지스터에 저장


<br>

**레지스터 간접** 주소 지정

![figure2](/assets/img/cs/img31.png)
