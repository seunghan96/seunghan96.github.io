---
title: 2-6) 운영체제 - 파일 시스템
categories: [CS, OS]
tags: []
excerpt: 
---

<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

(참고: Fastcampus 강의, 강민철의 인공지능 시대 필수 컴퓨터 공학 지식)

# 6. 파일 시스템

## Contents

1. 파일과 디렉터리
2. 파일 시스템이 만들어지기까지
3. 파일 시스템 종류와 특성

<br>

## (1) 파일과 디렉터리

### a) 파일 시스템

**파일 시스템**

( 쉬운 설명: **파일과 디렉토리를 저장하고, 관리하고, 찾을 수 있게 해주는 방법과 구조** )

- 파일과 디렉토리(폴더)를 관리하는 커널의 한 부분
- 다양한 파일 시스템이 있고, 여러 파일 시스템을 동시에 사용 가능

<br>

***파일 시스템이 필요한 이유?***

- 컴퓨터의 저장장치는 그냥 **빈 공간** (0과 1의 연속)

  $$\rightarrow$$ 이걸 그냥 쓰면 어떤 파일이 어디에 있는지, 어떤 게 어떤 데이터인지 **알 방법이 없어**

- 따라서, OS는 **파일 시스템이라는 규칙**을 만들어서

  - 파일을 저장
  - 이름 붙이고
  - 찾고
  - 삭제하고
  - 복사할 수 있게 해 줌

<br>

### b) 파일 

보조 기억장치의 "의미있는 정보의 집합"

구성 요소

- (1) 이름
- (2) 실행하기 위한 정보
- (3) 부가 정보 = 메타데이터/속성

<br>

블록 (block): 파일 접근 단위

- 참고) 섹터 단위로 접근하지 않음!

<br>

### c) 디렉토리 (경로)

- 상대 경로 & 절대 경로
- 많은 OS는, "디렉터리를 파일과 동일하게" 간주한다!

![figure2](/assets/img/cs/img123.png)

<br>

구성 요소

- (1) 파일 이름
- (2) 위치를 유추할 수 있는 정보
- (3) (파일 속성)

![figure2](/assets/img/cs/img124.png)

<br>

### d) 파일 유형 

![figure2](/assets/img/cs/img125.png)

<br>

## (2) 파일 시스템이 만들어지기까지

보조기억장치 1개에, 1개의 파일시스템이 사용되는 것이 아님!

$$\rightarrow$$ **파티셔닝 (partitioning)**

<br>

**파티셔닝 (partitioning)**

- 보조기억장치의 영역을 구획하는 작업
- 파티션 (partition) = 보조기억장치에서 구획된 영역

![figure2](/assets/img/cs/img126.png)

<br>

**포매팅 (formating)** 

- 파일 시스템을 만드는 작업

<br>

**마운트 (mount)**

- 파일 시스템을, 다른 파일 시스템에 편입

![figure2](/assets/img/cs/img127.png)

<br>

## (3) 파일 시스템 종류와 특성

(복습) 연속적으로 블록을 할당할 경우

$$\rightarrow$$ ***외부 단편화 발생***

<br>

### a) FAT 기반 파일 시스템

FAT(File Allocation Table)를 활용하는 파일 시스템

- 파일 조각들이 어디 저장돼 있는지 알려주는 “목차표”를 사용

<br>

동작 방식

- 저장 장치를 **작은 블록(클러스터)** 단위로 나눔
- 각 블록마다 **FAT라는 표**에 정보를 저장해둬
- 어떤 파일이 저장되면,
  - FAT에 **“이 파일은 블록 3 → 7 → 12에 저장됨”** 이런 식으로 **연결 정보를 기록**
  - 파일을 읽을 땐, FAT를 보고 블록들을 **순서대로 따라가며 읽음**

| **항목** | **내용**                                               |
| -------- | ------------------------------------------------------ |
| 장점     | 구조가 간단하고, 구현하기 쉬움                         |
| 단점     | 큰 파일이 많으면 조각나기 쉬움 (단편화), 성능이 떨어짐 |

![figure2](/assets/img/cs/img128.png)

<br>

### b) i-node 기반 파일 시스템

아이노드(i-node)라는 색인 블록을 활용한 파일 시스템

<br>

아이노드(i-node)란?

- **파일에 대한 정보를 담고 있는 작은 데이터 구조**
  - e.g., “이 파일은 어디에 저장돼 있고, 누가 만들었고, 몇 바이트야” 같은 **파일의 정체 정보**를 담고 있음

<br>

동작 방식

- 파일이 만들어지면, **i-node가 하나 생성됨**

- i-node에는

  - 파일의 **크기**

  - **소유자**

  - **권한**

  - **생성/수정 시간**

  - **실제 데이터가 저장된 블록 번호 목록**

    등이 저장돼

- 파일 시스템은 **파일 이름 → i-node 번호 → i-node → 실제 데이터 블록** 이런 흐름으로 접근

<br>

![figure2](/assets/img/cs/img130.png)

![figure2](/assets/img/cs/img129.png)

<br>

장점

- **파일 정보가 정리돼 있어서 효율적**
- **파일 이름과 분리돼 있어서**, 하나의 파일에 여러 이름(하드 링크)을 줄 수도 있음

<br>

### c) 둘 간의 비교

| **항목**                | **🧩 FAT 기반 파일 시스템**         | **📌 i-node 기반 파일 시스템**       |
| ----------------------- | ---------------------------------- | ----------------------------------- |
| **핵심 구조**           | FAT 테이블 (연결 리스트처럼 저장)  | i-node (파일 메타정보 + 블록 목록)  |
| **파일 위치 정보**      | FAT 테이블에 저장 (블록 연결 정보) | i-node에 저장 (직접 블록 주소 보유) |
| **파일 이름 저장 위치** | 디렉토리와 함께 저장됨             | 디렉토리에 이름 + i-node 번호 저장  |
| **접근 방식**           | FAT를 따라가며 블록 순서대로 읽음  | i-node에서 블록 위치 바로 참조      |
| **성능**                | 많은 블록 이동 필요 → 느릴 수 있음 | 직접 주소 접근 가능 → 빠름          |
| **단편화 문제**         | 조각 현상(단편화) 심함             | 상대적으로 적음                     |
| **링크(하드 링크)**     | 지원하지 않음                      | 하드 링크 지원 (i-node 공유)        |
| **유연성**              | 구조가 단순 → 소형 저장장치에 적합 | 기능 다양 → 고급 시스템에 적합      |

- **FAT**는 테이블에서 **블록 번호를 따라가는 구조**

  → 구현이 단순하고 작지만, **조각나기 쉽고 느릴 수 있음**

- **i-node**는 각 파일마다 **정보를 따로 갖고 있어서 효율적**

  → 큰 시스템에서도 성능이 좋고 **기능도 많음**

<br>

| **시스템** | **비유**                                                     |
| ---------- | ------------------------------------------------------------ |
| FAT        | 책의 내용을 여러 종이에 써놓고, **“다음 종이는 몇 번”** 적어둔 방식 |
| i-node     | 파일마다 **도서관 카드(i-node)**가 있고, 거기에 **어느 선반에 어떤 페이지가 있음** 적혀 있는 구조 |
